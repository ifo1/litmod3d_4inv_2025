! LitMod3D_4INV is a tool for multi-observable probabilistic inversions that uses previous
! information generated by LitMod1D_4INV, which is a 1D inversion module.
!
! Do not distribute any parts of this software without previous consent from the author
! New version and updates should be obtained from Juan Carlos Afonso (juan.afonso@mq.edu.au)

PROGRAM LITMOD3D_4INV

   use ptvars, only : MPI_SETUP, OPENMP_SETUP, COMMSIZE,ID0, COMMPCNT, PTT1, COMMCHACC, MPI_FINISH, ACCGLT1ACC, &
       COMMPCT1, COMMCHID, COMMSMID, ALLCOMM, SMPLCOMM, COMMNSMP, REQCHAINS, PTMTMIS, MPIPRECISION, COMMPCID
   use ptroutines, only: PTMPI_INIT
#ifdef MPI
   use ptroutines, only: PTMPI_EXCHANGEPTT
   use ptvars, only : SMPLCOMMID
#endif
   use M_grid_parameters, only: N_x,N_y,N_z, d_z, synt, minlaythickness
   use M_material, only: rho_c_ref, rho_c_temp, vp_vs,vp_c_temp,vs_c_temp, RHP, rho_s_ref
   use M_temperatures, only: HF, Tsurf, TLAB, Tref,NTref
   use temp_subs, only: TEMPERATURE_1D, TEMPERATURE_1D_COLUMN
   use column_subs, only: COLUMNS, COLUMN
   use M_layers, only: dept_c, NClay,layers,E_OBS,E_calc,uncert_el,NSlay
   use M_columns, only: SHF_OBS, BGA_OBS,FA,GEOID,GEOID_OBS,FA_OBS,FA_REF, &
       uncert_g,uncert_hf,uncert_bga,uncert_fa, FA_ind, GEOID_ind, gravupdfreq, &
       X_MCMC_MIN,Y_MCMC_MIN,X_MCMC_MAX,Y_MCMC_MAX, &
       Uxx_ind,Uyy_ind,Uzz_ind, Uxx,Uyy,Uzz, uncert_Uxx,uncert_Uyy,uncert_Uzz, &
       Uxx_OBS,Uyy_OBS,Uzz_OBS, Uxx_REF,Uyy_REF,Uzz_REF
   use globalvars, only: MCMCSTEPS, MCMCFIRSTSTEP
#ifdef CHECKS
   use globalvars, only: Z_BOT_INV
#endif
   use M_1D_INV, only: N_z_INV,z_nod,comp_nod,den_sys,vs_sys,vp_sys,den_ref_14,T_INV,P_INV, scalesubm,N_dif_comp,compmap,N_litho
   use SWCALC, only: ray_p,love_p,iper_l, iper_r, observed_love, &
       observed_ray, uncert_ray, swc_finish, swc_free_model, init_sw_maxper
   use sw_init, only: initialise_surfwaves, read_synt_period
   use SW_COMPUTE, only: FAST_SURF_LOVE, FAST_SURF_RAYLEIGH
   use extra_functions, only: CheckAllIOUnitsFreed,get_cpu_time, pack_index, unpack_index, nonfinite
#ifdef SMOOTHGRADGRAV
   use extra_functions, only: smoothing_window
#endif
   use iovars, only : write_numacc, inputdir, write_xyz, write_json, time_rtcalc, &
                      write_hdf5_time, write_png_time, write_xyz_time, mcmc_time, globtime, omcmctime, &
                      testmode, testlayernum, testlayerstep, mpitimeinit, mpitimept, &
                      time_covmat, time_grav, write_tiledb, write_tiledb_time
   use RANDOMVAL, only : init_random
   use screen_output, only: write_dashed_line, write_success_finish,int2str,print_min_aver_max, header, verstdout
   use perplex_interface, only: thermo, thermo_column
   use compute_creep, only: ATTEN
#ifdef HDF5WRT
   use hdf5_output, only : hdf5_write
   use iovars, only : write_hdf5
#endif
   use TDNODFUNC, only: TDNOD_PRESSURE, TDNOD_TEMP, TDNOD_DEPTH
   use LitMod_MPI_ExchangeData, only : LitMod_MPI_AllMax, LitMod_MPI_AllSum, LitMod_MPI_AllMin
   use PROPOSALCOMPONENTS, only : propcomp_memfree, ncolmodprop, cmupdfreq, burnin, cmupdlast, samplemoho, propbounds
   use FieldLeveller, only : LSQ_PLANE, BGA, Mean_Plane !these functions compute corrected gravity fields
   use raytracerstuff, only : update_raytrace, init_raytrace, rt_readrays, rtupdfreq, &
      finish_raytrace, rt_misfit, rt_misfit_col, rt_applytt,rt_copydata,rt_update_coldata, &
      litmod_reset_velfield, litmod_update_velfield,rt_writedata,rt_set_col,rt_unset_col
   use OrthoMCMC, only : OMCMCSTAGE
   use covmats_update, only: covmats_upd
#ifdef MPI
   use OrthoMCMC, only : omcmc_alloc_stat_arrays, omcmc_upd_stat_arrays, omcmc_ass_model, &
      omcmc_eval_dist, omcmc_dealloc_stat_arrays, omcmc_crt_model
#endif
   use MisfitVars, only: misfitwtlim, misfitwt, misfitlast,misfitmin,misfitlastcomp, &
      num_outbounds, num_failed, num_immirj
   use MisfitCalc, only: MisfitCalculate, MisfitDelta, scale_misfit, rescale_misfit, rescale_misfitwt
#ifdef TDBWRT
   use tiledb_binding_sparse, only: tiledbpostprocmode, tiledb_init, tiledb_write, tiledb_rollback
   use tiledb_primtosec, only: tiledb_convert
#endif
#ifdef PNGWRT
   use png_binding, only: png_write
   use iovars, only : write_png
#endif
   use sampling, only: create_sample, tryimmirj, select_columns, accept_model, domainregions
   use ioroutines, only: write_modelinfo,read_modelinfo, write_columnstruct, read_columnstruct, read_covmat, &
      write_observations, read_proplimits, write_proplimits, read_domregions, write_domregions, read_obs_grav, &
      read_obs_disprayl, read_obs_displove, read_obs_gravgrad, filter_dc_data, read_obs_rf, write_obs_rf
   use gravity_subs, only: GRAV_PRISM_UPDATE_REF, GRAV_PRISM, GRAV_SET_COORDS, &
      GRAV_PRISM_COLUMN_FREEAIR, GRAV_PRISM_COLUMN_GEOID, GRAV_PRISM_COLUMN_GRAD
   use proposaldata, only: d, realloc_prop_arr, fill_prop, realloc_prop, copy_d, broadcast_d,zero_prop, write_json_proposal
   use cmdline_options, only: get_paths
   use seismic_prep, only: crust_vps, redefine
   use RECFTNS, only: rfdata, misfit_rf
#ifdef THEO
   use theorf, only: rf_theo
#else
   use kennet, only: respknts
#endif
#ifdef HDF52KM
   use hdf5_output_2km, only: write_hdf5_TVpVsdens
   use iovars, only : write_hdf5_2km
#endif
   implicit none
   integer :: ikea = 0, iprop, write_counter=1 !number of MCMC simulation, index of a model, periodicity of writing
   real  :: AV, den_ref_14_loc
   integer :: n_nd, I_x, I_y, I_z, icol, delrj, nmaxtouch
   real, allocatable :: T(:,:,:), T_col(:), sqatt(:), vp_a_sys(:), vs_a_sys(:)
   logical :: compute_grav = .true.
   logical,allocatable :: compute_dc(:,:)
#ifdef MPI
   logical :: swapped = .false.
#endif

   !**************************************************************************************************
   ! Print greeting, setup Serial/MPI/OpenMP environment, set and report precisions for MPI data exchange
   call MPI_SETUP ()
   ! total execution time
   globtime = get_cpu_time()
   ! print greeting
   call header
   call write_dashed_line()
   ! set and report data precision primarily for MPI data exchange
   call MPIPRECISION()

   call get_paths ! parse the command line arguments to set the variables

   call OPENMP_SETUP()

   call write_dashed_line()

   !**************************************************************************************************
   ! detect mode: synthetics or inversion
   inquire(file=inputdir//'/synth.dat',exist=synt)

   !**************************************************************************************************
   ! Set up the Parallel Tempering environment
   mpitimept = mpitimept - get_cpu_time()
   call PTMPI_INIT ()
   mpitimept = mpitimept + get_cpu_time()

   !**************************************************************************************************
   !escape to solvers or to tests
   call testmodes()

   call write_dashed_line()
   if (ID0) write(*,*)'LitMod reads input files...'
   verstdout = verstdout .and. ID0 .and. REQCHAINS==1 !screen outputs for MCMC

   !**************************************************************************************************
   ! Read general model data

   call read_modelinfo()
   ! set boundaries for MCMC sampling using the values supplied via command line
   X_MCMC_MIN = min(N_x,max(1,X_MCMC_MIN))
   Y_MCMC_MIN = min(N_y,max(1,Y_MCMC_MIN))
   X_MCMC_MAX = max(1,min(N_x,X_MCMC_MAX))
   Y_MCMC_MAX = max(1,min(N_y,Y_MCMC_MAX))
   if (synt) then !no MCMC steps
      MCMCSTEPS = 0
   else
      !set the covariance matrix update periodicity
      if (cmupdfreq > 0) then
#ifndef TDBWRT
         stop "TileDB support is required to use Adaptive Metropolis!"
#endif
         if (.not.write_tiledb) stop "TileDB output must be stored to use CovMat update!"
         !convert user input of the number of CovMat updates to the number of steps
         !divide by the number of intervals, i.e. if the user ordered 1 update, it must happen after 50% of steps
         if (cmupdfreq == 0) stop "CovMat update frequency turns to be zero!"
         if (MCMCSTEPS/cmupdfreq < 1 .or. MCMCSTEPS/cmupdfreq>20) stop "Check the inputs: the number of CovMat updates turns to be greater than 20 or less than 1"
         if (cmupdfreq <= 1.5*burnin) stop "The CovMat update frequency must be greater than burnin"
         if (cmupdlast < 0) cmupdlast = (MCMCSTEPS/cmupdfreq) * cmupdfreq+1
         if (cmupdlast <= cmupdfreq) stop "The CovMat update period cannot exceed the MCMC step for the last update"
      endif
   endif

   !**************************************************************************************************
   ! read geophysical observables and initialise solvers

   ! initialise the surface wave calculator
   call initialise_surfwaves()

   call read_obs_grav()
   call read_obs_disprayl()
   call read_obs_displove()
   call read_obs_gravgrad()
   ! write a model which LitMod can read
   if (write_xyz .and. ID0) call write_modelinfo()
   !filter the dispersion data to exclude value in the oceans
   call filter_dc_data()

   ! read SW periods from a separate file if the observations were not supplied
   call read_synt_period()
   call init_sw_maxper()

   ! initialise the Ray Tracer
   call init_raytrace()

   ! read RF data
   call read_obs_rf()

   ! initialise the thermodynamic solver (Perple_X)
   call iniprp

   allocate (Tsurf(N_x,N_y), TLAB(N_x,N_y))
   Tsurf = 10.0
   TLAB = 1250.0

   !**************************************************************************************************
   ! print general information about the mesh
   if (ID0) call print_grid_summary

#ifdef TDBWRT
   ! if requested, escape to the primary-to-secondary TileDB converter
   if (tiledbpostprocmode) call tiledb_convert(1,1,N_x,N_y)
#endif

   !**************************************************************************************************
   ! Read or create model (columns) structure and mantle compositions
   ! This structure typically comes from a previous 1D inversion

   allocate (dept_c(N_x,N_y,NClay), vs_c_temp(N_x,N_y,NClay), vp_c_temp(N_x,N_y,NClay), rho_s_ref(N_x,N_y,NSlay), &
             rho_c_ref(N_x,N_y,NClay), layers(N_x,N_y,0:NClay+N_dif_comp), RHP(N_x,N_y,NClay+N_litho))
   allocate (Tref(N_x,N_y,NTref), scalesubm(N_x,N_y))

   if (synt) then
      call synthetic_maker ()
   else
      call read_columnstruct()
   endif

   !check the temperature fields
   if (any(Tref(:,:,1) < 1100. .or. Tref(:,:,1) > 1700.)) STOP "The initial temperature of the buffer node is out of range"
   if (any(Tref(:,:,2) < 1100. .or. Tref(:,:,2) > 1700.)) STOP "The initial temperature of the intermediate node is out of range"
   if (any(Tref(:,:,3) < 1250. .or. Tref(:,:,3) > 1800.)) STOP "The initial temperature at 410 km is out of range"

   ! calculate the SiO2 content
   comp_nod(:,:,:,1)=100.-sum(comp_nod(:,:,:,2:5),dim=4)
   if (any(comp_nod < 0. .or. comp_nod > 100.)) stop "Chemical composition is negative or greater than 100"

   !**************************************************************************************************
   ! alter the model if requested by user
   call change_layer_depth()
   call change_nod_comp()
   call change_crust_dens()

   !report layers (except the sediments) thinner than the fine grid spacing
   if (ID0) then
      do I_z = 2,NClay
         if (any ( dept_c(:,:,I_z) < d_z .and. dept_c(:,:,I_z) > minlaythickness) ) then
            call write_dashed_line()
            write(*,'(A,I0,A,f0.2,A)') ' WARNING: LAYER ', I_z,' THICKNESS IS LESS THAN dZ: ', &
               minval(dept_c(:,:,I_z),mask=dept_c(:,:,I_z)>minlaythickness), ' m'
            call write_dashed_line()
         endif
      enddo
      do I_z = NClay,NClay+N_dif_comp
         if (any ( layers(:,:,I_z-1)-layers(:,:,I_z) < d_z ) ) then
            call write_dashed_line()
            write(*,'(A,I0,A,f0.2,A)') ' WARNING: LAYER ', I_z,' IS THINNER THAN dZ: ', &
               minval(layers(:,:,I_z-1)-layers(:,:,I_z)), ' m'
            call write_dashed_line()
         endif
      enddo
   endif

   call check_spiralwalk ()
   !**************************************************************************************************
   if (ID0) then
      call write_dashed_line()
      write(*,*)'DOMAIN INITIALIZATION                   MIN     AVERAGE     MAX'
      write(*,*)''
      do I_z = 1, NClay
         write(*,'(a,i0,a)') ' Properties of the ',I_z,' crustal layer'
         call print_min_aver_max(N_x,N_y,dept_c(:,:,I_z),'   Thickness, m:')
         if (I_z<=NSlay) then
            call print_min_aver_max(N_x,N_y,rho_s_ref(:,:,I_z),'   Sedimentary Density, kg/m3:')
         endif
         call print_min_aver_max(N_x,N_y,rho_c_ref(:,:,I_z),'   Reference Density, kg/m3:')
         call print_min_aver_max(N_x,N_y,1000*vs_c_temp(:,:,I_z),'   Vs velocity, m/sec:')
         call print_min_aver_max(N_x,N_y,1000*vp_c_temp(:,:,I_z),'   Vp velocity, m/sec:')
         write(*,*)''
      enddo
   endif

   !assign depths to the thermodynamic nodes
   allocate (z_nod(N_x,N_y,N_z_INV))
   do I_x=1,N_x
      do I_y=1,N_y
         z_nod(I_x,I_y,:) = TDNOD_DEPTH(layers(I_x,I_y,0:NClay+N_dif_comp),compmap(I_x,I_y,1:N_dif_comp),N_z_INV)
      enddo
   enddo
   if (any (z_nod(:,:,1:N_z_INV-1) - z_nod(:,:,2:N_z_INV) > 0.)) stop "Critical error: Z_NOD is not monotonic"

   if(ID0) write(*,'(A)')' Assembling the 3D thermal structure from the set of 1D columns'
   allocate (HF(N_x,N_y),T_INV(N_x,N_y,N_z_INV),T(N_x,N_y,N_z))
   CALL TEMPERATURE_1D(T)

   !**************************************************************************************************

   ! Compute pressure at the thermodynamic nodes
   allocate (P_INV(N_x,N_y,N_z_INV))
   forall (I_x=1:N_x, I_y=1:N_y) p_inv(I_x,I_y,:) = TDNOD_PRESSURE(layers(I_x,I_y,:),rho_c_ref(I_x,I_y,:),compmap(I_x,I_y,N_dif_comp),z_nod(I_x,I_y,:))

   ! Compute physical properties in the nodes of the 1D inversion grid using Perple_X
   allocate(den_sys(N_x,N_y,N_z_INV), vs_sys(N_x,N_y,N_z_INV), vp_sys(N_x,N_y,N_z_INV), den_ref_14(N_x,N_y))
   call thermo()

   if(ID0) write(*,*)''

   ! Computes rho at the 3D grid (N_z) linearly interpolating from the 1D nodes
   ! Calculate node density, pressure, and elevation
   call COLUMNS(T)
   deallocate(T)

   !**************************************************************************************************
   !assemble computed blocks with geological structures from active CPUs and broadcast to all CPUs
   if (synt) SHF_OBS = HF
   if (any(abs(E_OBS(:,:)-layers(:,:,0))>minlaythickness)) stop "Elevation is not conserved!"

   !compute the Surface Heat Flux and Elevation misfits
   if (misfitwt(2)>misfitwtlim) then
      misfitlastcomp(2) = MisfitCalculate(N_x,N_y,E_OBS,E_calc,uncert_el)
   endif
   if (misfitwt(5)>misfitwtlim) then
      misfitlastcomp(5) = MisfitCalculate(N_x,N_y,SHF_OBS,HF,uncert_hf)
   endif

   !**************************************************************************************************
   ! gravity fields: anomalies, geoid heights and gravity gradients
   ! compute only if this misfit component is used (Bouguer, Geoid)
   compute_grav = (misfitwt(1)>misfitwtlim .or. misfitwt(4)>misfitwtlim .or. &
                   misfitwt(7)>misfitwtlim .or. misfitwt(8)>misfitwtlim)
   if (compute_grav) then
      if(ID0) write(*,*)''
      call GRAV_SET_COORDS(0.0,0.0,0.0)
      !gravity assembles data from MPI directly in subroutine; all CPUs must call it
      !compute reference model (averaged columns, including gravity gradients)
      CALL GRAV_PRISM_UPDATE_REF(ALLCOMM,COMMSIZE)
      ! compute gravity fields
      CALL GRAV_PRISM()
      !compute misfit if requested
      if (misfitwt(1)>misfitwtlim) then ! Bouguer anomaly
         misfitlastcomp(1) = MisfitCalculate(N_x,N_y,BGA_OBS,BGA(FA),uncert_bga)
      endif
      if (misfitwt(4)>misfitwtlim) then ! GEOID
         misfitlastcomp(4) = MisfitCalculate(N_x,N_y,GEOID_OBS,LSQ_PLANE(GEOID),uncert_g)
      endif
      if (misfitwt(7)>misfitwtlim) then ! gradients
#ifdef SMOOTHGRADGRAV
         misfitlastcomp(7) = &
            MisfitCalculate(N_x,N_y,Uxx_OBS,smoothing_window(MEAN_PLANE(Uxx-Uxx_REF,Uxx_OBS),3),uncert_Uxx) + &
            MisfitCalculate(N_x,N_y,Uyy_OBS,smoothing_window(MEAN_PLANE(Uyy-Uyy_REF,Uyy_OBS),3),uncert_Uyy) + &
            MisfitCalculate(N_x,N_y,Uzz_OBS,smoothing_window(MEAN_PLANE(Uzz-Uzz_REF,Uzz_OBS),3),uncert_Uzz)
#else
         misfitlastcomp(7) = &
            MisfitCalculate(N_x,N_y,Uxx_OBS,MEAN_PLANE(Uxx-Uxx_REF,Uxx_OBS),uncert_Uxx) + &
            MisfitCalculate(N_x,N_y,Uyy_OBS,MEAN_PLANE(Uyy-Uyy_REF,Uyy_OBS),uncert_Uyy) + &
            MisfitCalculate(N_x,N_y,Uzz_OBS,MEAN_PLANE(Uzz-Uzz_REF,Uzz_OBS),uncert_Uzz)
#endif
      endif
      if (misfitwt(8)>misfitwtlim) then ! Free Air
         misfitlastcomp(8) = MisfitCalculate(N_x,N_y,FA_OBS,MEAN_PLANE(FA-FA_REF,FA_OBS),uncert_fa)
      endif
   endif

   !**************************************************************************************************
   ! Crustal velocities
   allocate (vp_vs(N_x,N_y,NClay))
   vp_vs = 0.0
   where (vs_c_temp>0.0) vp_vs = vp_c_temp/vs_c_temp
   DO I_y=1,N_y
      DO I_x=1,N_x
         call CRUST_VPS((rho_c_temp(I_x,I_y,2,:)+rho_c_temp(I_x,I_y,1,:)) / 2000., &
             vp_vs(I_x,I_y,:),vp_c_temp(I_x,I_y,:),vs_c_temp(I_x,I_y,:))
         do n_nd = NClay-1,1,-1
            if (dept_c(I_x,I_y,n_nd)<minlaythickness) then
               vp_c_temp(I_x,I_y,n_nd) = vp_c_temp(I_x,I_y,n_nd+1)
               vs_c_temp(I_x,I_y,n_nd) = vs_c_temp(I_x,I_y,n_nd+1)
            endif
         enddo
      ENDDO
   ENDDO

   !**************************************************************************************************
   ! Ray Tracer - or skip
   ! this must be computed by each CPU for the full domain = each core must have all the data
   if (misfitwt(6)>misfitwtlim) then
      if (ID0) write(*,*) ''
      call rt_readrays()
      call litmod_reset_velfield()
      call update_raytrace(ALLCOMM,0)
      call rt_writedata()
      !compute misfit if MCMC uses this component - notice, this is a square, while update_raytrace reports RMS
      misfitlastcomp(6) = rt_misfit ()
   endif

   !**************************************************************************************************
   ! Dispersion Curves and Receiver Functions
   allocate (vs_a_sys(N_z_INV), vp_a_sys(N_z_INV), sqatt(N_z_INV))
   if ((misfitwt(3)>misfitwtlim .and. ( iper_r>0 .or. iper_l>0 )) .or. misfitwt(9)>misfitwtlim) then
      if(ID0) then
         write(*,*)''
         write(*,'(A)', advance="no")' Computing '
         if (misfitwt(3)>misfitwtlim) write(*,'(A)', advance="no")'dispersion curves'
         if (misfitwt(3)>misfitwtlim .and. misfitwt(9)>misfitwtlim) write(*,'(A)', advance="no") ' and '
         if (misfitwt(9)>misfitwtlim) write(*,'(A)', advance="no") 'receiver functions'
      endif
      AV = get_cpu_time()
      !allocate arrays to store the data
      DO I_z=1,N_x*N_y
         if (mod( I_z , COMMSIZE ) /= COMMPCID) cycle
         call unpack_index(I_z,N_x,I_x,I_y)
         ! compute attenuation effects
         call atten(    P_INV     (I_x,I_y,:), &
                        T_INV     (I_x,I_y,:), &
                        vs_sys    (I_x,I_y,:), &
                        vp_sys    (I_x,I_y,:), &
                        sqatt, vs_a_sys, vp_a_sys )
         !set a layer structure for the dispersion curve solver
         call redefine( I_x,I_y, &
                        z_nod     (I_x,I_y,:), &
                        dept_c    (I_x,I_y,:), &
                        layers    (I_x,I_y,:), &
                        den_sys   (I_x,I_y,:), &
                        rho_c_temp(I_x,I_y,:,:), &
                        vp_c_temp (I_x,I_y,:), &
                        vs_c_temp (I_x,I_y,:), &
                        sqatt, vs_a_sys, vp_a_sys )
         !compute dispersion curves
         if (iper_r>0) CALL FAST_SURF_RAYLEIGH(ray_p(I_x,I_y,:),n_nd)
         if (iper_l>0) CALL FAST_SURF_LOVE(love_p(I_x,I_y,:), n_nd)
         ! Receiver Function
         if (misfitwt(9)>misfitwtlim) then
            ! P wave Receiver Function
            n_nd=rfdata%prfmap(I_x,I_y)
            if (n_nd>0) then
#ifdef THEO
               rfdata%rf(n_nd)%calc = rf_theo(n_nd,E_OBS(I_x,I_y),dept_c(I_x,I_y,:))
#else
               rfdata%rf(n_nd)%calc = respknts(n_nd,E_OBS(I_x,I_y),dept_c(I_x,I_y,:))
#endif
               if (any(nonfinite(rfdata%rf(n_nd)%calc))) stop "P Receiver Functions: Some amplitudes are NaN or Inf"
            endif
            ! S wave Receiver Function
            n_nd=rfdata%srfmap(I_x,I_y)
            if (n_nd>0) then
#ifdef THEO
               stop "No SRF can be computed with the THEO package"
#else
               rfdata%rf(n_nd)%calc = respknts(n_nd,E_OBS(I_x,I_y),dept_c(I_x,I_y,:))
#endif
               if (any(nonfinite(rfdata%rf(n_nd)%calc))) stop "S Receiver Functions: Some amplitudes are NaN or Inf"
            endif
         endif
         call swc_free_model()
      ENDDO
      if(ID0) write(*,'(a,F0.2,a)') ' ... in ', get_cpu_time()-AV, ' sec'

      !collect and broadcast computed blocks with SW from active CPUs and broadcast to all CPUs
      if (iper_r>0) then
         mpitimeinit = mpitimeinit - get_cpu_time()
         ray_p  = LitMod_MPI_AllSum(N_x,N_y,iper_r,ray_p,ALLCOMM)
         mpitimeinit = mpitimeinit + get_cpu_time()
         if (synt) observed_ray = ray_p
         where (observed_ray < epsilon(0.0)) ray_p=observed_ray
         if (ID0) then
            call print_min_aver_max(N_x,N_y,iper_r,ray_p,(ray_p>0),'   Rayleigh wave phase velocity, m/s:')
            if (synt) then
               write(*,'(A)')'   Computed Rayleigh phase velocities assigned to observations'
            else
               call print_min_aver_max(N_x,N_y,iper_r,observed_ray,(observed_ray>0),'   Observed Rayleigh PV, m/s:')
            endif
         endif
         misfitlastcomp(3) = MisfitCalculate(N_x,N_y,iper_r,observed_ray,ray_p,uncert_ray)
      endif
      if (iper_l>0) then
         mpitimeinit = mpitimeinit - get_cpu_time()
         love_p = LitMod_MPI_AllSum(N_x,N_y,iper_l,love_p,ALLCOMM)
         mpitimeinit = mpitimeinit + get_cpu_time()
         if (synt) observed_love = love_p
         where (observed_love<0.0) love_p=observed_love
         if (ID0) then
            call print_min_aver_max(N_x,N_y,iper_l,love_p,(love_p>0),'   Love wave phase velocity, m/s:')
            if (synt) then
               write(*,'(A)')'   Computed Love phase velocities assigned to observations'
            else
               call print_min_aver_max(N_x,N_y,iper_l,observed_love,(observed_love>0),'   Observed Love PV, m/s:')
            endif
         endif
      endif
      if (misfitwt(9)>misfitwtlim) then
         mpitimeinit = mpitimeinit - get_cpu_time()
         rfdata%rf(:)%misfit = 0.0
         if (rfdata%nrec /= size(rfdata%rf)) &
            stop "The number of RF records does not match the size of array"
         do n_nd = 1, rfdata%nrec
            rfdata%rf(n_nd)%calc = LitMod_MPI_AllSum(rfdata%rf(n_nd)%nsamp,rfdata%rf(n_nd)%calc,ALLCOMM)
            if (synt) rfdata%rf(n_nd)%obs = rfdata%rf(n_nd)%calc
            rfdata%rf(n_nd)%misfit = misfit_rf( &
                     rfdata%rf(n_nd)%nsamp, &
                     rfdata%rf(n_nd)%obs, &
                     rfdata%rf(n_nd)%calc, &
                     rfdata%rf(n_nd)%uncert)
            if (count(rfdata%prfmap == n_nd) + count(rfdata%srfmap == n_nd) /= 1) &
               stop "Some of the RFs are not mapped to columns or are mapped multiple times"
         enddo
         mpitimeinit = mpitimeinit + get_cpu_time()
         if (ID0) then
            if (synt) then
               write(*,'(A)')'   Computed Receiver Functions assigned to observations'
            else
               call print_min_aver_max(rfdata%nrec,rfdata%rf(:)%nsamp*rfdata%sampl_int(rfdata%rf(:)%wave), &
               '   Receiver Function duration, s:')
            endif
         endif
         misfitlastcomp(9) = sum(rfdata%rf(:)%misfit)
      endif
   endif

   !**************************************************************************************************
   ! penalty for negative density contrast in the crust
   if (misfitwt(10)>misfitwtlim) then
      misfitlastcomp(10) = 0
      do n_nd=2,NClay
         misfitlastcomp(10) = misfitlastcomp(10) + sum(max(0.0,rho_c_ref(:,:,n_nd-1)-rho_c_ref(:,:,n_nd)))
      enddo
   endif

   !collect running time
   mpitimeinit = LitMod_MPI_AllSum(mpitimeinit,ALLCOMM)/real(COMMSIZE)

   !*************************************************************************************************
   if (.not.synt) then ! initialise the misfit calculator
      if(ID0) write(*,*)' '
      call write_dashed_line()
      call scale_misfit(misfitlastcomp(:))
      if (misfitlast < 1. .and. testmode/=4 .and. MCMCSTEPS>0) &
         stop "ERROR: the initial misfit value is less than 1! Apply another scaling!"
      if(ID0) write(*,*)''
      call write_dashed_line()

      !**************************************************************************************************
      ! CHECK THE UPDATE FREQUENCY
      if (gravupdfreq<=0 .or. gravupdfreq>MCMCSTEPS .or. REQCHAINS>1 .or..not.compute_grav) then
         gravupdfreq = MCMCSTEPS+1
         if(ID0) write(*,*)'NOTE: the gravity reference model will not be updated'
         call write_dashed_line()
      endif
      if (misfitwt(6)<=misfitwtlim .or. rtupdfreq<=0 .or. rtupdfreq>MCMCSTEPS .or. REQCHAINS>1) then
         rtupdfreq = MCMCSTEPS+1
         if(ID0) write(*,*)'NOTE: the body wave ray tracing reference model will not be updated'
         call write_dashed_line()
      endif

   endif

   call read_proplimits()

   ! write a model which LitMod can read
   if (write_xyz .and. ID0) then
      ! output computed model
      write(*,*)''
      call write_dashed_line()
      call write_observations() !dump observations
      call write_obs_rf() !dump RFs
      call write_observations(MCMCFIRSTSTEP) !write computed observables
      call write_obs_rf(MCMCFIRSTSTEP) !write computed RFs
      call write_columnstruct(MCMCFIRSTSTEP)
      call write_proplimits()
   endif


   !switch to sampling of the Moho instead of the last crustal layer
   if (any(samplemoho > 0.0)) then
      samplemoho = samplemoho/100.0
      icol = N_dif_comp*5 + NTRef+NSlay+3*NClay
      propbounds(:,:,1,icol) = sum(dept_c,dim=3)
      propbounds(:,:,2,icol) = (1.0+samplemoho(2))*propbounds(:,:,1,icol)
      propbounds(:,:,3,icol) = min(1500.0,sum(samplemoho)/20.0*propbounds(:,:,1,icol))
      propbounds(:,:,1,icol) = (1.0-samplemoho(1))*propbounds(:,:,1,icol)
   endif

   !**************************************************************************************************
   ! write the initial state of the model
#ifdef HDF5WRT
   if (write_hdf5 .and. COMMSMID==0) call hdf5_write (0)
#endif
#ifdef HDF52KM
   if (write_hdf5_2km .and. COMMSMID==0) call write_hdf5_TVpVsdens ()
#endif
#ifdef TDBWRT
   if (write_tiledb .and. COMMSMID==0 .and. .not.(synt.and..not.ID0)) then
      allocate (ncolmodprop(N_x,N_y,REQCHAINS))
      ncolmodprop = 1
      call tiledb_init()
      do I_x = 1, N_x
         do I_y = 1, N_y
            call tiledb_write(0,I_x,I_y)
         enddo
      enddo
      if (MCMCSTEPS==0) call tiledb_write(-1,-1,-1) !finalize the record
      deallocate (ncolmodprop)
   endif
#endif
#ifdef PNGWRT
   if (write_png) call png_write(0)
#endif

   if (MCMCSTEPS == 0) then
      call memfree(compute_grav)
      deallocate (vs_a_sys, vp_a_sys, sqatt)
      call propcomp_memfree()
      call CheckAllIOUnitsFreed()
      call write_success_finish()
      call MPI_FINISH () !must be called in serial version as well
   endif

   !**************************************************************************************************
   ! THE INITIAL A PRIORI IS COMPUTED AND WRITTEN
   !**************************************************************************************************
   ! MCMC part

   mcmc_time = -get_cpu_time()

   if(ID0) write(*,*)' '
   call write_dashed_line()
   if(ID0) write(*,*)'                    ---- MARKOV CHAINS START ----'
   if(ID0) write(*,*)' '
   ! initialize a PRNG (set with -r option)
   call init_random
   if(ID0) write(*,*)' '

   !**************************************************************************************************
   ! Read boundaries for MCMC chains
   call read_domregions()

   call read_covmat ()

   if (write_xyz) call write_domregions()

   allocate (ncolmodprop(N_x,N_y,REQCHAINS), T_col(N_z),compute_dc(N_x,N_y))
   ncolmodprop = 0; T_col=0.0
   compute_dc = .false.
   do I_x = 1, N_x
      do I_y = 1, N_y
         if (iper_r>0) compute_dc(I_x,I_y) = any(observed_ray(I_x,I_y,:)>0.0)
         if (iper_l>0) compute_dc(I_x,I_y) = compute_dc(I_x,I_y) .or. any(observed_love(I_x,I_y,:)>0.0)
         if (misfitwt(9)>misfitwtlim) then
            compute_dc(I_x,I_y) = compute_dc(I_x,I_y) .or. rfdata%prfmap(I_x,I_y)>0 .or. rfdata%srfmap(I_x,I_y)>0
         endif
      enddo
   enddo

   if (ID0) write(*,*)' '

   !**************************************************************************************************

#ifdef MPI
   ! if OMCMC is on, each proposal array must be accompanied with assisting arrays to store average and average squared value
   ! to compute OMCMC refence models during horizontal steps
   call OMCMC_alloc_stat_arrays ()
#endif

   !**************************************************************************************************
   ! MCMC sampling
   do ikea=max(MCMCFIRSTSTEP,1),MCMCSTEPS

      !**************************************************************************************************
      !if user requested dynamic misfit rescaling
      call rescale_misfit (ikea)
      call rescale_misfitwt (ikea)

#ifdef MPI
      !**************************************************************************************************
      ! if OMCMC is possible, it may shrink the range of columns during horizontal phase
      if (OMCMCSTAGE(ikea) /= "N") then !any MCMC mode
         call OMCMC_upd_stat_arrays(ikea,layers,rho_c_ref,vp_vs,comp_nod)
      endif

      if (OMCMCSTAGE(ikea) == "H") then
         !if Orthogonal MCMC and Horizontal stage, recompute the whole domain
         omcmctime = omcmctime - get_cpu_time()
         !assemble whole model of averages
         call OMCMC_ass_model (ikea)
         !compute distances
         call OMCMC_eval_dist (misfitlast,layers,rho_c_ref,vp_vs,comp_nod)
         !after this point, OMCMCSWAPCHN contains the PTT=1 MCMC to be tested
         omcmctime = omcmctime + get_cpu_time()
         !setup the number of models to be computed
         COMMPCNT = 1 !for the full model
      endif
#endif
      !**************************************************************************************************
      ! reallocate arrays - needed if the number of proposals changed
      call realloc_prop_arr(COMMPCNT)
      ! select the columns to modify - the same column(s) for all proposals
      if (COMMSMID==0) then
         call select_columns(ikea,1,compute_grav)
         n_nd = d(1)%ncol
      else
         n_nd = 0
      endif
      ! broadcast the data to another CPUs
      if (COMMNSMP>1) then
         n_nd = LitMod_MPI_AllSum(n_nd,SMPLCOMM)
         if (COMMSMID/=0) call realloc_prop(1,n_nd,compute_grav)
         d(1)%ix = LitMod_MPI_AllSum(d(1)%ncol,d(1)%ix,SMPLCOMM)
         d(1)%iy = LitMod_MPI_AllSum(d(1)%ncol,d(1)%iy,SMPLCOMM)
      endif
      !increment the counter - implies that all proposals modify the same column(s)
      forall (icol = 1:d(1)%ncol) ncolmodprop (d(1)%ix(icol),d(1)%iy(icol),COMMCHID) = ncolmodprop (d(1)%ix(icol),d(1)%iy(icol),COMMCHID) + 1
      !allocate the same columns on the rest of proposals
      do iprop = 2, COMMPCNT
         call realloc_prop(iprop,d(1)%ncol,compute_grav)
         d(iprop)%ix = d(1)%ix
         d(iprop)%iy = d(1)%iy
      enddo

      ! methods with delayed rejection
      do delrj = 1, 2
         ! the first go:
         ! for MTM : create a set of proposals to choose from
         ! the second go:
         ! for MTM : create the second set of proposals using the given sample

         !fill properties with default values
         if (delrj == 1) then
            nmaxtouch = 0
            do iprop = 1,COMMPCNT
               do icol = 1, d(iprop)%ncol
                  I_x = d(iprop)%ix(icol); I_y = d(iprop)%iy(icol)
                  nmaxtouch = max(nmaxtouch,ncolmodprop (I_x,I_y,COMMCHID))
#if CHECKS
                  call zero_prop (iprop,compute_grav)
#endif
                  call fill_prop (iprop, icol)
               enddo
            enddo
         else ! create a proposal using the stored one
            if (COMMSMID+1==COMMNSMP) then
               call zero_prop(COMMPCNT,compute_grav)
               COMMPCNT=COMMPCNT-1 !omit computation of the last proposal in the case of MTM
            endif
            do iprop = 1,COMMPCNT
               call zero_prop(iprop,compute_grav)
               call copy_d (0,iprop,compute_grav)
            enddo
         endif

         !**************************************************************************************************
         ! perturb a column / columns
         if (testmode==4) then !spiral walk test mode - assuming single proposal
            do icol = 1, d(1)%ncol
               d(1)%layers (testlayernum,icol) = d(1)%layers (testlayernum,icol) + testlayerstep
            enddo
            d(1)%dept_c(1:NClay,:) = d(1)%layers(0:NClay-1,:) - d(1)%layers(1:NClay,:)

#ifdef MPI
         elseif (OMCMCSTAGE(ikea) == "H") then ! Horizontal phase of OMCMC - assuming single proposal
            call zero_prop(1,compute_grav)
            do icol = 1, d(1)%ncol
               I_x = d(1)%ix(icol); I_y = d(1)%iy(icol)
               d(1)%Tref(:,icol) = Tref(I_x,I_y,:)
               call OMCMC_crt_model(I_x,I_y,d(1)%layers(:,icol),d(1)%rho_c_ref(:,icol),d(1)%vp_vs(:,icol),d(1)%comp_nod(:,:,icol))
            enddo
            d(1)%dept_c(1:NClay,:) = d(1)%layers(0:NClay-1,:) - d(1)%layers(1:NClay,:)
#endif
         else ! default MCMC
            do iprop = 1,COMMPCNT
               do icol = 1, d(iprop)%ncol
                  ! select a new crustal model or compositional node to perturb
                  call create_sample( d(iprop)%ix(icol),d(iprop)%iy(icol), &
                                      d(iprop)%vp_vs        (:,icol), &
                                      d(iprop)%dept_c       (:,icol), &
                                      d(iprop)%rho_s_ref    (:,icol), &
                                      d(iprop)%rho_c_ref    (:,icol), &
                                      d(iprop)%layers       (:,icol), &
                                      d(iprop)%Tref         (:,icol), &
                                      d(iprop)%comp_nod   (:,:,icol), &
                                      d(iprop)%Csubmoho       (icol), &
                                      d(iprop)%reject)
               enddo
            enddo
         endif

         num_outbounds = num_outbounds + count(d(1:COMMPCNT)%reject>0)

         !**************************************************************************************************
         !proposal computation - temperature, pressure, density
         do iprop = 1,COMMPCNT
            if (d(iprop)%reject/=0) cycle
            do icol = 1, d(iprop)%ncol
               I_x = d(iprop)%ix(icol) ; I_y = d(iprop)%iy(icol) !restore shortened acronyms

               ! get locations of thermodynamic nodes
               d(iprop)%z_nod(:,icol) = TDNOD_DEPTH(d(iprop)%layers(:,icol),compmap(I_x,I_y,1:N_dif_comp),N_z_INV)
               if (any (d(iprop)%z_nod(1:N_z_INV-1,icol) - d(iprop)%z_nod(2:N_z_INV,icol) >= 0.)) then
                  print *, "Z_NOD is not monotonic; the LAB is too deep"
                  d(iprop)%reject = -21
                  exit
               endif

               ! get new fine mesh temperature profile (the geotherm)
               call TEMPERATURE_1D_COLUMN(  T_col, &
                                            compmap(I_x,I_y,N_litho), &
                                            compmap(I_x,I_y,N_dif_comp), &
                                            d(iprop)%z_nod  (:,icol), &
                                            d(iprop)%layers (:,icol), &
                                            d(iprop)%HF       (icol), &
                                            Tsurf(I_x,I_y)       , &
                                            TLAB           (I_x,I_y), &
                                            d(iprop)%Tref   (:,icol), &
                                            RHP          (I_x,I_y,:) )
               ! interpolate T to the thermodynamic nodes
               d(iprop)%T_INV(:,icol) = TDNOD_TEMP(T_col, &
                                            compmap(I_x,I_y,N_litho), &
                                            compmap(I_x,I_y,N_dif_comp), &
                                            d(iprop)%z_nod(:,icol), &
                                            TLAB           (I_x,I_y), &
                                            d(iprop)%Tref   (:,icol))
#ifdef CHECKS
               if (any(d(iprop)%T_INV(:,icol)>2000. .or. d(iprop)%T_INV(:,icol)<0.)) stop "Temperature is out of range"
#endif
               ! compute P at the thermodynamic nodes
               d(iprop)%P_INV(:,icol) = TDNOD_PRESSURE(d(iprop)%layers(:,icol),d(iprop)%rho_c_ref(:,icol),compmap(I_x,I_y,N_dif_comp),d(iprop)%z_nod(:,icol))

               ! get all relevant parameters from free energy minimization
               call THERMO_COLUMN(  compmap              (I_x,I_y,:), &
                                    d(iprop)%z_nod         ( :,icol), &
                                    d(iprop)%P_INV          (:,icol), &
                                    d(iprop)%T_INV          (:,icol), &
                                    d(iprop)%comp_nod     (:,:,icol), &
                                    den_ref_14_loc,                &
                                    d(iprop)%den_sys        (:,icol), &
                                    d(iprop)%vs_sys         (:,icol), &
                                    d(iprop)%vp_sys         (:,icol), &
                                    d(iprop)%Csubmoho         (icol))

               ! compute rho and velocities at the 3D grid (N_z) linearly interpolating from the 1D nodes
               call COLUMN       (  compmap (I_x,I_y,N_litho), &
                                    compmap (I_x,I_y,N_dif_comp), &
                                    d(iprop)%z_nod          (:,icol), &
                                    T_col,                            &
                                    Tsurf                  (I_x,I_y), &
                                    d(iprop)%E_calc           (icol), &
                                    den_ref_14_loc,                   &
                                    d(iprop)%den_sys        (:,icol), &
                                    d(iprop)%rho_s_ref      (:,icol), &
                                    d(iprop)%rho_c_ref      (:,icol), &
                                    d(iprop)%rho_c_temp   (:,:,icol), &
                                    d(iprop)%layers         (:,icol), AV, &
                                    d(iprop)%reject ) ! AV==P_iso is a dummy parameter
               if (d(iprop)%reject .ne. 0) exit
               !Fast checks of models
#ifdef CHECKS
               if (abs ( d(iprop)%layers(0,icol) - layers(I_x,I_y,0) ) > epsilon(0.0)) STOP __FILE__//": ELEVATION IS NOT CONSERVED"
               if (abs ( Z_BOT_INV + d(iprop)%layers(NClay+N_dif_comp,icol) ) > epsilon(0.0)) STOP __FILE__//": Z_BOT_INV IS NOT CONSERVED"
#endif
            enddo

            ! Surface heat flux
            if (misfitwt(5)>misfitwtlim .and. d(iprop)%reject==0) then
               d(iprop)%misfitval(5) = misfitlastcomp(5) + MisfitDelta(N_x,N_y,SHF_OBS,HF,uncert_hf,&
                                       d(iprop)%ncol,d(iprop)%ix,d(iprop)%iy,d(iprop)%HF) * misfitwt(5)
               d(iprop)%reject = tryimmirj(sum(d(iprop)%misfitval(:)))
            endif
            if (misfitwt(2)>misfitwtlim .and. d(iprop)%reject==0) then
               ! Elevation
               d(iprop)%misfitval(2) = misfitlastcomp(2) + MisfitDelta(N_x,N_y,E_OBS,E_calc,uncert_el,&
                                       d(iprop)%ncol,d(iprop)%ix,d(iprop)%iy,d(iprop)%E_calc) * misfitwt(2)
               !try to reject immediately
               d(iprop)%reject = tryimmirj(sum(d(iprop)%misfitval(:)))
            endif
         enddo

         !**************************************************************************************************
         !proposal computation - seismic velocities

         !set columns for the storage
         if (misfitwt(6)>misfitwtlim) then
            call rt_set_col(d(1)%ncol,d(1)%ix,d(1)%iy,delrj)
         endif

         do iprop = 1,COMMPCNT
            if (d(iprop)%reject/=0) cycle
            do icol = 1, d(iprop)%ncol ! get Vs and Vp for crustal layers
               call CRUST_VPS    (  sum(d(iprop)%rho_c_temp(:,:,icol),dim=1) / 2000., & ! IN
                                    d(iprop)%vp_vs          (:,icol), & ! IN
                                    d(iprop)%vp_c_temp      (:,icol), & ! OUT
                                    d(iprop)%vs_c_temp      (:,icol) )  ! OUT
               do n_nd = NClay-1,1,-1
                  if (d(iprop)%dept_c(n_nd,icol)<minlaythickness) then
                     d(iprop)%vp_c_temp(n_nd,icol) = d(iprop)%vp_c_temp(n_nd+1,icol)
                     d(iprop)%vs_c_temp(n_nd,icol) = d(iprop)%vs_c_temp(n_nd+1,icol)
                  endif
               enddo
            enddo

            if (misfitwt(6)>misfitwtlim) then
               call litmod_reset_velfield()
               do icol = 1, d(iprop)%ncol
                  call litmod_update_velfield(d(iprop)%ix(icol),d(iprop)%iy(icol), &
                     (/ d(iprop)%vp_c_temp(:,icol) , d(iprop)%vp_sys(:,icol) /), &
                     (/ d(iprop)%vs_c_temp(:,icol) , d(iprop)%vs_sys(:,icol) /), &
                     (/ -d(iprop)%layers(0:NClay,icol) , d(iprop)%z_nod(:,icol) /) )
               enddo
               d(iprop)%misfitval(6) = rt_misfit_col(d(iprop)%ncol,d(iprop)%ix,d(iprop)%iy,delrj) * misfitwt(6)
               !try to reject immediately
               d(iprop)%reject = tryimmirj(sum(d(iprop)%misfitval(:)))
               if (d(iprop)%reject .ne. 0) exit
            endif

            if (misfitwt(3)>misfitwtlim .or. misfitwt(9)>misfitwtlim) then
               do icol = 1, d(iprop)%ncol
                  I_x = d(iprop)%ix(icol) ; I_y = d(iprop)%iy(icol)
                  d(iprop)%prfmisfit = 0
                  d(iprop)%srfmisfit = 0
                  ! skip a column without data
                  if (.not.compute_dc(I_x,I_y)) cycle
                  ! compute frequency-independent attenuation effects
                  call ATTEN     (  d(iprop)%P_INV          (:,icol), &
                                    d(iprop)%T_INV          (:,icol), &
                                    d(iprop)%vs_sys         (:,icol), &
                                    d(iprop)%vp_sys         (:,icol), &
                                    sqatt, vs_a_sys, vp_a_sys )

                  ! define a seismic velocity structure - a_ref0,b_ref0,rho_ref0,d_ref0
                  call REDEFINE  (  I_x,I_y, &
                                    d(iprop)%z_nod          (:,icol), &
                                    d(iprop)%dept_c         (:,icol), &
                                    d(iprop)%layers         (:,icol), &
                                    d(iprop)%den_sys        (:,icol), &
                                    d(iprop)%rho_c_temp   (:,:,icol), &
                                    d(iprop)%vp_c_temp      (:,icol), &
                                    d(iprop)%vs_c_temp      (:,icol), &
                                    sqatt, vs_a_sys, vp_a_sys )

                  ! Rayleigh Dispersion curve
                  if (iper_r>0) then
                     CALL FAST_SURF_RAYLEIGH ( d(iprop)%cR0(:,icol) , d(iprop)%reject )
                     if (d(iprop)%reject .ne. 0) exit
                     where (observed_ray(I_x,I_y,:)<epsilon(0.0)) d(iprop)%cR0(:,icol)=observed_ray(I_x,I_y,:)
                  endif
                  ! Love Dispersion curve
                  if (iper_l>0) then
                     CALL FAST_SURF_LOVE ( d(iprop)%cL0(:,icol) , d(iprop)%reject )
                     if (d(iprop)%reject .ne. 0) exit
                     where (observed_love(I_x,I_y,:)<epsilon(0.0)) d(iprop)%cL0(:,icol)=observed_love(I_x,I_y,:)
                  endif
                  ! Receiver Function
                  if (misfitwt(9)>misfitwtlim) then
                     ! P wave Receiver Function
                     n_nd=rfdata%prfmap(I_x,I_y)
                     if (n_nd>0) then
#ifdef THEO
                        rfdata%rf(n_nd)%calc = rf_theo(n_nd,E_OBS(I_x,I_y),d(iprop)%dept_c(:,icol))
#else
                        rfdata%rf(n_nd)%calc = respknts(n_nd,E_OBS(I_x,I_y),d(iprop)%dept_c(:,icol))
#endif
                        d(iprop)%prfmisfit(icol) = misfit_rf( &
                           rfdata%rf(n_nd)%nsamp, &
                           rfdata%rf(n_nd)%obs, &
                           rfdata%rf(n_nd)%calc, &
                           rfdata%rf(n_nd)%uncert) - &
                           rfdata%rf(n_nd)%misfit
                     else
                        d(iprop)%prfmisfit = 0
                     endif
                     ! S wave Receiver Function
                     n_nd=rfdata%srfmap(I_x,I_y)
                     if (n_nd>0) then
#ifdef THEO
                        rfdata%rf(n_nd)%calc = rf_theo(n_nd,E_OBS(I_x,I_y),d(iprop)%dept_c(:,icol))
#else
                        rfdata%rf(n_nd)%calc = respknts(n_nd,E_OBS(I_x,I_y),d(iprop)%dept_c(:,icol))
#endif
                        d(iprop)%srfmisfit(icol) = misfit_rf( &
                           rfdata%rf(n_nd)%nsamp, &
                           rfdata%rf(n_nd)%obs, &
                           rfdata%rf(n_nd)%calc, &
                           rfdata%rf(n_nd)%uncert) - &
                           rfdata%rf(n_nd)%misfit
                     else
                        d(iprop)%srfmisfit = 0
                     endif
                  endif
                  call swc_free_model()
               enddo

               if (d(iprop)%reject .ne. 0) then
                  call swc_free_model()
               else
                  if (misfitwt(3)>misfitwtlim) then
                     d(iprop)%misfitval(3) = misfitlastcomp(3) + MisfitDelta(N_x,N_y,iper_r,observed_ray,ray_p,uncert_ray, &
                                             d(iprop)%ncol,d(iprop)%ix,d(iprop)%iy,d(iprop)%cR0) * misfitwt(3)
                  endif
                  if (misfitwt(9)>misfitwtlim) then
                     d(iprop)%misfitval(9) = misfitlastcomp(9) + (sum(d(iprop)%prfmisfit) + sum(d(iprop)%srfmisfit)) * misfitwt(9)
                  endif
                  d(iprop)%reject = tryimmirj(sum(d(iprop)%misfitval(:)))
               endif

            endif

         enddo !Compute different proposals

         !**************************************************************************************************
         ! penalty for negative density contrast in the crust
         if (misfitwt(10)>misfitwtlim) then
            d(1:COMMPCNT)%misfitval(10) = 0.0
            do iprop = 1,COMMPCNT
               do icol = 1, d(iprop)%ncol
                  I_x = d(iprop)%ix(icol) ; I_y = d(iprop)%iy(icol)
                  d(iprop)%misfitval(10) = d(iprop)%misfitval(10) - &
                     sum(max(0.0,(rho_c_ref(I_x,I_y,1:NClay-1)-rho_c_ref(I_x,I_y,2:NClay)))) + &
                     sum(max(0.0,(d(iprop)%rho_c_ref(1:NClay-1,icol)-d(iprop)%rho_c_ref(2:NClay,icol))))
               enddo
            enddo
            d(1:COMMPCNT)%misfitval(10) = misfitlastcomp(10) + d(1:COMMPCNT)%misfitval(10) * misfitwt(10)
         endif

         !**************************************************************************************************
         ! Gravity
         if (compute_grav) then
            do iprop = 1, COMMPCNT
               if (d(iprop)%reject/=0) cycle
               !assign total gravity fields to the proposal
               if (misfitwt(1)>misfitwtlim .or. misfitwt(8)>misfitwtlim) d(iprop)%FA = FA
               if (misfitwt(4)>misfitwtlim) d(iprop)%GEOID = GEOID
               if (misfitwt(7)>misfitwtlim) then
                  d(iprop)%Uxx = Uxx
                  d(iprop)%Uyy = Uyy
                  d(iprop)%Uzz = Uzz
               endif
               do icol = 1,d(iprop)%ncol
                  I_x = d(iprop)%ix(icol) ; I_y = d(iprop)%iy(icol) !restore shortened acronyms

                  if (misfitwt(1)>misfitwtlim .or. misfitwt(8)>misfitwtlim) then
                     d(iprop)%FA_ind(:,:,icol)    = FA_ind(:,:,I_x,I_y)
                     call GRAV_PRISM_COLUMN_FREEAIR( I_x,I_y, &
                                          d(iprop)%layers        (:,icol), &
                                          d(iprop)%rho_c_temp  (:,:,icol), &
                                          d(iprop)%z_nod         (:,icol), &
                                          d(iprop)%den_sys       (:,icol), &
                                          d(iprop)%FA, &
                                          d(iprop)%FA_ind      (:,:,icol) )
                  endif

                  if (misfitwt(4)>misfitwtlim) then
                     d(iprop)%GEOID_ind(:,:,icol) = GEOID_ind(:,:,I_x,I_y)
                     ! compute bouguer anomaly and geoid height
                     call GRAV_PRISM_COLUMN_GEOID( I_x,I_y, &
                                             d(iprop)%layers        (:,icol), &
                                             d(iprop)%rho_c_temp  (:,:,icol), &
                                             d(iprop)%z_nod         (:,icol), &
                                             d(iprop)%den_sys       (:,icol), &
                                             d(iprop)%GEOID, &
                                             d(iprop)%GEOID_ind   (:,:,icol) )
                  endif

                  if (misfitwt(7)>misfitwtlim) then
                     d(iprop)%Uxx_ind(:,:,icol) = Uxx_ind(:,:,I_x,I_y)
                     d(iprop)%Uyy_ind(:,:,icol) = Uyy_ind(:,:,I_x,I_y)
                     d(iprop)%Uzz_ind(:,:,icol) = Uzz_ind(:,:,I_x,I_y)
                     ! compute bouguer anomaly and geoid height
                     call GRAV_PRISM_COLUMN_GRAD( I_x,I_y, &
                                             d(iprop)%layers        (:,icol), &
                                             d(iprop)%rho_c_temp  (:,:,icol), &
                                             d(iprop)%z_nod         (:,icol), &
                                             d(iprop)%den_sys       (:,icol), &
                                             d(iprop)%Uxx, &
                                             d(iprop)%Uxx_ind     (:,:,icol), &
                                             d(iprop)%Uyy, &
                                             d(iprop)%Uyy_ind     (:,:,icol), &
                                             d(iprop)%Uzz, &
                                             d(iprop)%Uzz_ind     (:,:,icol) )
                  endif
               enddo

               ! Bouguer anomaly
               if (misfitwt(1)>misfitwtlim) d(iprop)%misfitval(1) = &
                  MisfitCalculate(N_x,N_y,BGA_OBS,BGA(d(iprop)%FA),uncert_bga) * misfitwt(1)
               ! Geoid
               if (misfitwt(4)>misfitwtlim) d(iprop)%misfitval(4) = &
                  MisfitCalculate(N_x,N_y,GEOID_OBS,LSQ_PLANE(d(iprop)%GEOID),uncert_g) * misfitwt(4)
               ! Free Air
               if (misfitwt(8)>misfitwtlim) d(iprop)%misfitval(8) = &
                  MisfitCalculate(N_x,N_y,FA_OBS,MEAN_PLANE(d(iprop)%FA-FA_REF,FA_OBS),uncert_fa) * misfitwt(8)
               ! Gravity Gradients
               if (misfitwt(7)>misfitwtlim) then
#ifdef SMOOTHGRADGRAV
                  d(iprop)%misfitval(7) = misfitwt(7) * ( &
                     MisfitCalculate(N_x,N_y,Uxx_OBS,smoothing_window(MEAN_PLANE(d(iprop)%Uxx-Uxx_REF,Uxx_OBS),3),uncert_Uxx) + &
                     MisfitCalculate(N_x,N_y,Uyy_OBS,smoothing_window(MEAN_PLANE(d(iprop)%Uyy-Uyy_REF,Uyy_OBS),3),uncert_Uyy) + &
                     MisfitCalculate(N_x,N_y,Uzz_OBS,smoothing_window(MEAN_PLANE(d(iprop)%Uzz-Uzz_REF,Uzz_OBS),3),uncert_Uzz) )
#else
                  d(iprop)%misfitval(7) = misfitwt(7) * ( &
                     MisfitCalculate(N_x,N_y,Uxx_OBS,MEAN_PLANE(d(iprop)%Uxx-Uxx_REF,Uxx_OBS),uncert_Uxx) + &
                     MisfitCalculate(N_x,N_y,Uyy_OBS,MEAN_PLANE(d(iprop)%Uyy-Uyy_REF,Uyy_OBS),uncert_Uyy) + &
                     MisfitCalculate(N_x,N_y,Uzz_OBS,MEAN_PLANE(d(iprop)%Uzz-Uzz_REF,Uzz_OBS),uncert_Uzz) )
#endif
               endif
            enddo
         endif

         I_x = -666 ; I_y = -666 !to avoid any usage by causing out-of-range exception
         icol = count(d(1:COMMPCNT)%reject==-100)
         num_failed = num_failed + count(d(1:COMMPCNT)%reject<-1) - icol
         num_immirj = num_immirj + icol

         !**************************************************************************************************
         !Apply criteria to accept or reject (or choose) the proposal
         forall (iprop = 1:COMMPCNT)
            d(iprop)%misfit = merge( sum(d(iprop)%misfitval) , huge(0.) , d(iprop)%reject == 0)
         endforall

         !omit computation of the last proposal in the case of MTM
         if (delrj==2 .and. COMMSMID+1==COMMNSMP) then
            COMMPCNT=COMMPCNT+1
            d(COMMPCNT)%misfitval = 0.0
            d(COMMPCNT)%misfit = misfitlast
         endif

         iprop = accept_model(OMCMCSTAGE(ikea) == "H",d(:)%misfit,delrj,nmaxtouch)

         if (write_json) call write_json_proposal (ikea,delrj,iprop)

         ! exit if not an MTM
         if (PTMTMIS .or. (COMMNSMP==1 .and. COMMPCNT==1) ) exit
         ! exit if MTM but no valid proposal was found
         if (iprop==0) exit
         ! always exit if this is the second go
         if (delrj==2) exit

         !**************************************************************************************************
         ! for MTM: store the pre-selected proposal to generate new samples
         call copy_d (iprop,0,compute_grav)
#ifdef MPI
         iprop = 0
         call broadcast_d(iprop,SMPLCOMMID)
#endif
      enddo ! end delrj

      !**************************************************************************************************
      !Apply changes to a model if proposal was accepted
      if (iprop > 0) then !we accepted a certain model
         if (PTT1()) ACCGLT1ACC = ACCGLT1ACC + 1
         COMMCHACC = COMMCHACC + 1 ! number of accepted models

         if (d(0)%ncol>0) then !means this is a delayed-rejection method
            iprop = 0
#ifdef MPI
         elseif (COMMNSMP > 1) then
            call broadcast_d(iprop,SMPLCOMMID)
#endif
         endif

#ifdef MPI
         if (misfitwt(6)>misfitwtlim .and. COMMNSMP > 1) then
            !proposal at site 1 has the same location(s), but is always (MTMIS v MTM) definted
            call rt_copydata(d(1)%ncol,d(1)%ix,d(1)%iy,SMPLCOMMID,SMPLCOMM)
         endif
#endif

         !copy the data from temporary variables to the general storage
         if(d(iprop)%reject/=0) stop "Rejected proposal was accepted!"
         misfitlastcomp(:) = d(iprop)%misfitval(:)
         misfitlast = sum(misfitlastcomp)
         if (PTT1()) misfitmin = min(misfitmin, misfitlast) ! save minimum misfit

         if (misfitwt(6)>misfitwtlim) call rt_applytt(d(1)%ncol,d(1)%ix,d(1)%iy)

         if (misfitwt(1)>misfitwtlim .or. misfitwt(8)>misfitwtlim) FA = d(iprop)%FA
         if (misfitwt(4)>misfitwtlim) GEOID = d(iprop)%GEOID
         if (misfitwt(7)>misfitwtlim) then
            Uxx  =  d(iprop)%Uxx
            Uyy  =  d(iprop)%Uyy
            Uzz  =  d(iprop)%Uzz
         endif
         do icol = 1,d(iprop)%ncol
            I_x = d(iprop)%ix(icol) ; I_y = d(iprop)%iy(icol)
            if (iper_r>0)  ray_p  (I_x,I_y,:)  =  d(iprop)%cR0  (:,icol)
            if (iper_l>0) love_p  (I_x,I_y,:)  =  d(iprop)%cL0  (:,icol)
            if (misfitwt(1)>misfitwtlim .or. misfitwt(8)>misfitwtlim) &
               FA_ind     (:,:,I_x,I_y)  =  d(iprop)%FA_ind     (:,:,icol)
            if (misfitwt(4)>misfitwtlim) GEOID_ind  (:,:,I_x,I_y)  =  d(iprop)%GEOID_ind  (:,:,icol)
            if (misfitwt(7)>misfitwtlim) then
               Uxx_ind  (:,:,I_x,I_y)  =  d(iprop)%Uxx_ind  (:,:,icol)
               Uyy_ind  (:,:,I_x,I_y)  =  d(iprop)%Uyy_ind  (:,:,icol)
               Uzz_ind  (:,:,I_x,I_y)  =  d(iprop)%Uzz_ind  (:,:,icol)
            endif
            if (misfitwt(9)>misfitwtlim) then
               n_nd=rfdata%prfmap(I_x,I_y)
               if (n_nd>0) rfdata%rf(n_nd)%misfit = rfdata%rf(n_nd)%misfit + d(iprop)%prfmisfit(icol)
               n_nd=rfdata%srfmap(I_x,I_y)
               if (n_nd>0) rfdata%rf(n_nd)%misfit = rfdata%rf(n_nd)%misfit + d(iprop)%srfmisfit(icol)
            endif
            P_INV        (I_x,I_y,:)    =  d(iprop)%P_INV        (:,icol)    ! from PRESSURE
            den_sys      (I_x,I_y,:)    =  d(iprop)%den_sys      (:,icol)    ! from thermo_column
            vp_sys       (I_x,I_y,:)    =  d(iprop)%vp_sys       (:,icol)    ! from thermo_column
            vs_sys       (I_x,I_y,:)    =  d(iprop)%vs_sys       (:,icol)    ! from thermo_column
            T_INV        (I_x,I_y,:)    =  d(iprop)%T_INV        (:,icol)    ! from TEMPERATURE_1D_COLUMN
            dept_c       (I_x,I_y,:)    =  d(iprop)%dept_c       (:,icol)
            layers       (I_x,I_y,:)    =  d(iprop)%layers       (:,icol)
            z_nod        (I_x,I_y,:)    =  d(iprop)%z_nod        (:,icol)
            if (NSlay>0) then
               rho_s_ref    (I_x,I_y,:)    =  d(iprop)%rho_s_ref    (:,icol)    ! from COLUMN
            endif
            rho_c_ref    (I_x,I_y,:)    =  d(iprop)%rho_c_ref    (:,icol)    ! from COLUMN
            vp_vs        (I_x,I_y,:)    =  d(iprop)%vp_vs        (:,icol)    ! from select_crust
            vp_c_temp    (I_x,I_y,:)    =  d(iprop)%vp_c_temp    (:,icol)    ! from crust_vps
            vs_c_temp    (I_x,I_y,:)    =  d(iprop)%vs_c_temp    (:,icol)    ! from crust_vps
            comp_nod     (I_x,I_y,:,:)  =  d(iprop)%comp_nod   (:,:,icol)
            rho_c_temp   (I_x,I_y,:,:)  =  d(iprop)%rho_c_temp (:,:,icol)
            E_calc       (I_x,I_y)      =  d(iprop)%E_calc         (icol)
            HF           (I_x,I_y)      =  d(iprop)%HF             (icol)
            Tref         (I_x,I_y,:)    =  d(iprop)%Tref         (:,icol)
            scalesubm    (I_x,I_y)      =  d(iprop)%Csubmoho       (icol)
         enddo

         !**************************************************************************************************
         ! write outputs if any
         if (verstdout) then
            write(*,'(a,i0,a,F0.2,a,3(i0,a))') ' State ',ACCGLT1ACC,' with misfit ', misfitlast,&
                       ' accepted at iteration ',ikea, ' while ', &
                       num_failed,' proposals failed and ',num_outbounds,' are out of bounds'
         endif
         if (COMMSMID == 0) then
#ifdef TDBWRT
            if (write_tiledb) then ! writes by chain ID, so not PTT dependent
               do icol = 1,d(iprop)%ncol
                  I_x = d(iprop)%ix(icol) ; I_y = d(iprop)%iy(icol) ! must be the same on all CPUs
                  call tiledb_write(ikea, I_x,I_y)
               enddo
            endif
#endif
            if (PTT1()) then
               !output full model
               if (mod(write_counter,write_numacc)==0) then
#ifdef HDF5WRT
                  if (write_hdf5) call hdf5_write (ikea)
#endif
#ifdef PNGWRT
                  if (write_png) call png_write(ikea)
#endif
                  if (write_xyz) then
                     call write_columnstruct(ikea)
                     call write_observations(ikea)
                     call write_obs_rf(ikea)
                  endif
               endif
            endif
         endif
         write_counter = write_counter + 1

         forall (icol = 1:d(iprop)%ncol) ncolmodprop (d(iprop)%ix(icol),d(iprop)%iy(icol),COMMCHID) = 0

#ifdef CHECKS
         if (any(abs ( layers(:,:,0) - E_OBS(:,:) ) > epsilon(0.0))) STOP __FILE__//": ASSIGNED ELEVATION IS NOT CONSERVED"
         if (any(abs ( Z_BOT_INV + layers(:,:,NClay+N_dif_comp) ) > epsilon(0.0))) STOP __FILE__//": ASSIGNED Z_BOT_INV IS NOT CONSERVED"
#endif

      endif ! iprop >=1; means proposal was accepted

      if (misfitwt(6)>misfitwtlim) then ! deallocate RT proposals
         call rt_unset_col(d(1)%ncol,d(1)%ix,d(1)%iy)
      endif

      !**************************************************************************************************
      !... write outputs on screen
      if(mod(ikea,max(1,MCMCSTEPS/100))==0 .and. COMMCHID == 1 .and. COMMSMID==0) then ! ... write on screen every 1% (only if nsimu > 100)
         iprop = int(100.*real(ikea)/real(MCMCSTEPS))
         if(mod(iprop,max(1,MCMCSTEPS/10))==0)then   ! ... write some information on screen every 10%
            write(*,*)''
            write(*,'(A,I3,A,F8.1,A)')' ------------- ', iprop,'% performed in ',get_cpu_time() + mcmc_time,' sec -----------------------'

            write(*,'(A,F5.1,A)') ' - Current acceptance rate: ',real(ACCGLT1ACC)/real(ikea*COMMPCT1)*100.0,'%'
            write(*,'(A,F0.2)') ' - Minimum misfit so far: ', misfitmin

            call write_dashed_line()
            write(*,*) ' '
         else
            write(*,'(a,i0,a,i0,a,f0.1,a)') ' simulation # ',ikea,' -- ', iprop,'% performed in ',get_cpu_time() + mcmc_time,' sec'
         endif  ! write every 10%
      endif    ! write every
#ifdef MPI

      !**************************************************************************************************
      !SKIP THE REST (PT SWAPS AND REFERENCE UPDATES) IF THE LAST STEP
      if (ikea==MCMCSTEPS) exit

      !**************************************************************************************************
      ! PARALLEL TEMPERING, CHAIN SWAPPING - THE MAIN ROUTINE
      mpitimept = mpitimept - get_cpu_time()
      swapped = PTMPI_EXCHANGEPTT(min(iprop,1),ikea,misfitlast)
      mpitimept = mpitimept + get_cpu_time()

      ! EXPLICIT MODEL UPDATE TO ALL OTHER SAMPLERS - PERFORM IF MTM/MTMIS AND PTT SWAP ACCEPTED
      if (COMMNSMP > 1 .and. swapped) call smplcomm_bcast()

#ifdef TDBWRT
      if (write_tiledb .and. COMMSMID==0 .and. swapped) then
         do I_x = 1, N_x
            do I_y = 1, N_y
               call tiledb_write(ikea,I_x,I_y)
            enddo
         enddo
      endif
#endif
#endif

      !**************************************************************************************************
      !update covariance matrices
      call covmats_upd(ikea)

      !**************************************************************************************************
      !update reference models
      if (mod(ikea,gravupdfreq)==0) then
         mcmc_time = mcmc_time + get_cpu_time()
         call GRAV_PRISM_UPDATE_REF(SMPLCOMM,COMMNSMP)
         if (misfitwt(1) > misfitwtlim) misfitlastcomp(1) = MisfitCalculate(N_x,N_y,BGA_OBS,BGA(FA),uncert_bga)*misfitwt(1)
         if (misfitwt(8) > misfitwtlim) misfitlastcomp(8) = MisfitCalculate(N_x,N_y,FA_OBS,MEAN_PLANE(FA-FA_REF,FA_OBS),uncert_fa)*misfitwt(8)
         if (misfitwt(4) > misfitwtlim) misfitlastcomp(4) = MisfitCalculate(N_x,N_y,GEOID_OBS,LSQ_PLANE(GEOID),uncert_g)*misfitwt(4)
#ifdef SMOOTHGRADGRAV
         if (misfitwt(7) > misfitwtlim) misfitlastcomp(7) = misfitwt(7) * &
            MisfitCalculate(N_x,N_y,Uxx_OBS,smoothing_window(MEAN_PLANE(Uxx-Uxx_REF,Uxx_OBS),3),uncert_Uxx) + &
            MisfitCalculate(N_x,N_y,Uyy_OBS,smoothing_window(MEAN_PLANE(Uyy-Uyy_REF,Uyy_OBS),3),uncert_Uyy) + &
            MisfitCalculate(N_x,N_y,Uzz_OBS,smoothing_window(MEAN_PLANE(Uzz-Uzz_REF,Uzz_OBS),3),uncert_Uzz)
#else
         if (misfitwt(7) > misfitwtlim) misfitlastcomp(7) = misfitwt(7) * &
            MisfitCalculate(N_x,N_y,Uxx_OBS,MEAN_PLANE(Uxx-Uxx_REF,Uxx_OBS),uncert_Uxx) + &
            MisfitCalculate(N_x,N_y,Uyy_OBS,MEAN_PLANE(Uyy-Uyy_REF,Uyy_OBS),uncert_Uyy) + &
            MisfitCalculate(N_x,N_y,Uzz_OBS,MEAN_PLANE(Uzz-Uzz_REF,Uzz_OBS),uncert_Uzz)
#endif
         misfitlast = sum(misfitlastcomp)
         mcmc_time = mcmc_time - get_cpu_time()
      endif
      if (mod(ikea,rtupdfreq)==0) then
         mcmc_time = mcmc_time + get_cpu_time()
         call rt_update_coldata()
         mcmc_time = mcmc_time - get_cpu_time()
      endif

   enddo ! ikea, random columns in the model
   mcmc_time = mcmc_time + get_cpu_time()

   call realloc_prop_arr(-1)
#ifdef MPI
   call OMCMC_dealloc_stat_arrays ()
#endif

#ifdef TDBWRT
   call tiledb_write(-1,-1,-1) !output the data forcibly
#endif
   deallocate (ncolmodprop,T_col,domainregions, sqatt, vp_a_sys, vs_a_sys,compute_dc)

   !***************************************************************************
   ! free memory
   call memfree(compute_grav)

   write_xyz_time = LitMod_MPI_AllSum(write_xyz_time,ALLCOMM)
   write_hdf5_time = LitMod_MPI_AllSum(write_hdf5_time,ALLCOMM)
   write_tiledb_time = LitMod_MPI_AllSum(write_tiledb_time,ALLCOMM)
   write_png_time = LitMod_MPI_AllSum(write_png_time,ALLCOMM)

   time_covmat = LitMod_MPI_AllSum(time_covmat,ALLCOMM)/real(COMMSIZE)
   time_grav = LitMod_MPI_AllSum(time_grav,ALLCOMM)/real(COMMSIZE)
   time_rtcalc = LitMod_MPI_AllSum(time_rtcalc,ALLCOMM)/real(COMMSIZE)

   mpitimept = LitMod_MPI_AllSum(mpitimept,ALLCOMM)/real(COMMSIZE)
   omcmctime = LitMod_MPI_AllSum(omcmctime,ALLCOMM)/real(COMMSIZE)
   num_outbounds = LitMod_MPI_AllSum(num_outbounds,ALLCOMM)
   num_failed = LitMod_MPI_AllSum(num_failed,ALLCOMM)

   call propcomp_memfree()
   call CheckAllIOUnitsFreed()

   call write_success_finish()

   call MPI_FINISH()

END PROGRAM LITMOD3D_4INV

!**********************************************************************

subroutine memfree(compute_grav)
#ifdef HDF5WRT
   use hdf5,only: h5close_f
   use iovars, only: write_hdf5
   use ptvars, only: COMMSMID
#endif
   use iovars, only: sufheader, sufcrust, sufmantle, sufrayleigh, sufgravgrad, &
      sufgravelev, sufrecfunc, suftravelt, sufpropcrust, sufpropmantle
   use M_grid_parameters, only: lon,lat,vectD
   use M_material, only: rho_c_ref, rho_c_temp, vp_vs,vp_c_temp,vs_c_temp, rockprop, RHP,rho_s_ref
   use M_temperatures, only: HF, Tsurf, TLAB, Tref
   use M_layers, only: dept_c, layers,E_OBS,E_calc,uncert_el
   use M_columns, only: B_corr,SHF_OBS, BGA_OBS,FA,FA_OBS,GEOID,GEOID_OBS,FA_ind,GEOID_ind, &
       Uxx_OBS,Uyy_OBS,Uzz_OBS,Uxx_ind,Uyy_ind,Uzz_ind,uncert_Uxx,uncert_Uyy,uncert_Uzz,&
       uncert_g,uncert_hf,uncert_bga,uncert_fa, FA_REF,GEOID_REF, &
       Uxx,Uxx_REF,Uyy,Uyy_REF,Uzz,Uzz_REF
   use M_1D_INV, only: z_nod,comp_nod,den_sys,vs_sys,vp_sys,T_INV,P_INV,scalesubm,compmap
   use SWCALC, only: ray_p,love_p,iper_l, iper_r, observed_love, &
       observed_ray, uncert_love, uncert_ray, period_l, period_r, swc_finish
   use raytracerstuff, only : finish_raytrace
   use gravity_subs, only: GRAV_FREE_COORDS
   use MisfitVars, only: misfitwt,misfitwtlim
   implicit none
   logical, intent(in) :: compute_grav
#ifdef HDF5WRT
   integer :: err
#endif

   deallocate (Tsurf, TLAB, Tref, scalesubm)
   if (misfitwt(1)>misfitwtlim .or. misfitwt(8)>misfitwtlim) deallocate (FA_ind)
   if (misfitwt(4)>misfitwtlim) deallocate (GEOID_ind)
   if (misfitwt(7)>misfitwtlim) deallocate (Uxx_ind,Uyy_ind,Uzz_ind)
   if (compute_grav) then
      deallocate (FA, GEOID, B_corr, FA_REF, GEOID_REF)
      deallocate (Uxx,Uxx_REF,Uyy,Uyy_REF,Uzz,Uzz_REF)
      call GRAV_FREE_COORDS()
   endif
   if (iper_r>0 .or. iper_l>0) call swc_finish()
   if(iper_l>0) deallocate (period_l,love_p,observed_love,uncert_love)
   if(iper_r>0) deallocate (period_r,ray_p,observed_ray,uncert_ray)
   deallocate (Uxx_OBS, Uyy_OBS, Uzz_OBS,uncert_Uxx,uncert_Uyy,uncert_Uzz)
   deallocate (uncert_fa,uncert_hf,uncert_g,SHF_OBS)
   deallocate (compmap)
   deallocate (sufheader, sufcrust, sufmantle, sufrayleigh, sufgravgrad, sufgravelev, &
      sufrecfunc, suftravelt, sufpropcrust, sufpropmantle)
   deallocate( z_nod, comp_nod, P_INV, T_INV, den_sys, layers, HF, E_OBS, uncert_el, &
      vp_vs, vp_sys, vs_sys, E_calc, uncert_bga, lon, lat, GEOID_OBS, FA_OBS, BGA_OBS, &
      rockprop, rho_c_ref, dept_c, vs_c_temp, vp_c_temp, rho_c_temp, RHP,vectD,rho_s_ref)
   call finish_raytrace()
#ifdef HDF5WRT
   if (COMMSMID==0 .and. write_hdf5) call h5close_f(err)
#endif
end subroutine memfree

!**********************************************************************

subroutine smplcomm_bcast()
   use M_layers, only: layers,E_calc, dept_c, NClay,NSlay
   use M_grid_parameters, only: N_x,N_y
   use M_1D_INV, only: N_z_INV,P_INV,T_INV,Z_NOD,den_sys,vs_sys,vp_sys,comp_nod,compmap,N_dif_comp
   use M_columns, only: FA_ind,GEOID_ind,FA,GEOID,Uxx,Uxx_ind,Uyy,Uyy_ind,Uzz,Uzz_ind
   use extra_functions, only: get_cpu_time
   use iovars, only: mpitimepropex
   use M_temperatures, only: HF,Tref,NTref
   use MisfitVars, only: misfitcomp,misfitlastcomp,misfitwt,misfitwtlim,misfitlast
   use M_material, only: vs_c_temp,vp_c_temp,vp_vs,rho_c_temp,rho_c_ref,rho_s_ref
   use SWCALC, only: iper_r,ray_p,iper_l,love_p
   use ptvars, only: SMPLCOMM,PTT1
   use LitMod_MPI_ExchangeData, only : LitMod_MPI_Broadcast
   use TDNODFUNC, only: TDNOD_DEPTH
   use seismic_prep, only: crust_vps
   use RECFTNS, only: rfdata
   implicit none
   integer :: I_x,I_y

   mpitimepropex = mpitimepropex - get_cpu_time()

   ! update misfit components
   call LitMod_MPI_Broadcast(misfitcomp,misfitlastcomp,0,SMPLCOMM)
   misfitlast = sum(misfitlastcomp)

   ! SCALAR VARS
   call LitMod_MPI_Broadcast(N_x,N_y,E_calc, 0,SMPLCOMM)
   call LitMod_MPI_Broadcast(N_x,N_y,HF,     0,SMPLCOMM)
   call LitMod_MPI_Broadcast(N_x,N_y,NTref,Tref,0,SMPLCOMM)
   ! SW VARS
   if (iper_r>0) call LitMod_MPI_Broadcast(N_x,N_y,iper_r,ray_p, 0,SMPLCOMM)
   if (iper_l>0) call LitMod_MPI_Broadcast(N_x,N_y,iper_l,love_p,0,SMPLCOMM)
   ! N_Z_INV vars
   call LitMod_MPI_Broadcast(N_x,N_y,N_z_INV,P_INV,  0,SMPLCOMM)
   call LitMod_MPI_Broadcast(N_x,N_y,N_z_INV,T_INV,  0,SMPLCOMM)
   call LitMod_MPI_Broadcast(N_x,N_y,N_z_INV,den_sys,0,SMPLCOMM)
   call LitMod_MPI_Broadcast(N_x,N_y,N_z_INV,vs_sys,0,SMPLCOMM)
   call LitMod_MPI_Broadcast(N_x,N_y,N_z_INV,vp_sys,0,SMPLCOMM)
   ! Other vars
   call LitMod_MPI_Broadcast(N_x,N_y,NClay,vp_vs, 0,SMPLCOMM)
   call LitMod_MPI_Broadcast(N_x,N_y,NClay+N_dif_comp+1,layers,0,SMPLCOMM)
   dept_c(:,:,1:NClay) = layers(:,:,0:NClay-1) - layers(:,:,1:NClay)
   forall (I_x=1:N_x,I_y=1:N_y) z_nod(I_x,I_y,:) = TDNOD_DEPTH(layers(I_x,I_y,:),compmap(I_x,I_y,1:N_dif_comp),N_z_INV)
   ! Gravity fields
   if (misfitwt(1)>misfitwtlim .or. misfitwt(8)>misfitwtlim) then
      call LitMod_MPI_Broadcast(N_x,N_y,N_x,N_y,FA_ind,0,SMPLCOMM)
      call LitMod_MPI_Broadcast(N_x,N_y,FA,0,SMPLCOMM)
   endif
   if (misfitwt(4)>misfitwtlim) then
      call LitMod_MPI_Broadcast(N_x,N_y,N_x,N_y,GEOID_ind,0,SMPLCOMM)
      call LitMod_MPI_Broadcast(N_x,N_y,GEOID,0,SMPLCOMM)
   endif
   if (misfitwt(7)>misfitwtlim) then
      call LitMod_MPI_Broadcast(N_x,N_y,N_x,N_y,Uxx_ind,0,SMPLCOMM)
      call LitMod_MPI_Broadcast(N_x,N_y,Uxx,0,SMPLCOMM)
      call LitMod_MPI_Broadcast(N_x,N_y,N_x,N_y,Uyy_ind,0,SMPLCOMM)
      call LitMod_MPI_Broadcast(N_x,N_y,Uyy,0,SMPLCOMM)
      call LitMod_MPI_Broadcast(N_x,N_y,N_x,N_y,Uzz_ind,0,SMPLCOMM)
      call LitMod_MPI_Broadcast(N_x,N_y,Uzz,0,SMPLCOMM)
   endif
   if (misfitwt(9)>misfitwtlim) then
      call LitMod_MPI_Broadcast(rfdata%nrec,rfdata%rf(:)%misfit,0,SMPLCOMM)
   endif
   !other vars
   call LitMod_MPI_Broadcast(N_x,N_y,N_dif_comp,5,comp_nod,0,SMPLCOMM)
   call LitMod_MPI_Broadcast(N_x,N_y,NClay,rho_c_ref,0,SMPLCOMM)
   if (NSlay>0) call LitMod_MPI_Broadcast(N_x,N_y,NClay,rho_s_ref,0,SMPLCOMM)
   call LitMod_MPI_Broadcast(N_x,N_y,2,NClay,rho_c_temp,0,SMPLCOMM)
   do I_x = 1,N_x
      do I_y = 1,N_y
         call CRUST_VPS((rho_c_temp(I_x,I_y,2,:)+rho_c_temp(I_x,I_y,1,:)) / 2000., &
             vp_vs(I_x,I_y,:),vp_c_temp(I_x,I_y,:),vs_c_temp(I_x,I_y,:))
      enddo
   enddo

!TODO   call LitMod_MPI_Broadcast(raydata%nrays,raydata%rays(:)%ttsq,0,SMPLCOMM)

   mpitimepropex = mpitimepropex + get_cpu_time()
end subroutine smplcomm_bcast

!**********************************************************************

subroutine print_grid_summary
   ! lists grid summary
   USE M_grid_parameters, only:d_x,d_y,N_z, lat, N_x, N_y, d_z, min_lon, max_lon, min_lat, max_lat, synt
   USE M_layers, only: NClay
   USE PROPOSALCOMPONENTS, only: gaussian,enforce_limits,use_cov_mat,cmupdfreq
   USE M_1D_INV, only: N_z_INV,N_litho,N_dif_comp
   use globalvars, only: MCMCSTEPS, pi
   use M_columns, only: X_MCMC_MIN, X_MCMC_MAX, Y_MCMC_MIN, Y_MCMC_MAX
   use extra_functions, only: unpack_index
   use iovars, only: write_numacc, write_hdf5
   use screen_output, only: write_dashed_line
   implicit none

   write(*,*)''
   call write_dashed_line()
   write(*,*)'Grid parameters:'
   write(*,'(a,i0,a,F6.2,a,F6.2)')'   Longitude (X): ', N_x, ' cells with centres from ', min_lon,' to ', max_lon
   write(*,'(a,i0,a,F6.2,a,F6.2)')'   Latitude (Y):  ', N_y, ' cells with centres from ', min_lat,' to ', max_lat
   write(*,'(a,F6.3,1X,F6.3)')'   Grid spacing          dx, dy (degree): ', d_x, d_y
   write(*,'(a,5(1X,F0.1))')  '             dx1, dx2, dy1, dy2, dz (km): ', &
            111.320*cos(lat(1)/180.*pi)*d_x, 111.320*cos(lat(N_y)/180.*pi)*d_x, &
            d_y * ( 110.567+(111.699-110.567)*abs(lat(1))/90.0 ), &
            d_y * ( 110.567+(111.699-110.567)*abs(lat(N_y))/90.0 ), d_z/1000.
   write(*,'(a,I0)')'   Thermodynamic nodes:                     ', N_z_INV
   write(*,'(a,I0)')'   Number of fine mesh grid nodes:          ', N_z
   write(*,'(a,I0)')'   Number of crustal layers:                ', NClay
   write(*,'(a,I0)')'   Number of layers in the lithosphere:     ', NClay+1
   write(*,'(a,I0)')'   Number of lithospheric mantle layers:    ', N_litho
   write(*,'(a,I0)')'   Total number of mantle layers:           ', N_dif_comp
   call write_dashed_line()
   if (MCMCSTEPS > 0) then
      write(*,*)'Simulation mode: solving inversion with MCMC'
      write(*,'(a,I0,a)',advance="no")'   Performing ', MCMCSTEPS, ' MCMC steps'

      if (use_cov_mat .and. cmupdfreq > 0) then
#ifdef TDBWRT
         write(*,'(a,i0,a)')' using Covariance Matrices with updates every ', cmupdfreq, ' simulations'
#else
         stop "LitMod3D_4inv was compiled without TileDB support required to update Cov Mats!"
#endif
      elseif (use_cov_mat .and. cmupdfreq <= 0) then
         write(*,'(a,i0,a)')' using Covariance Matrices'
      else
         if (gaussian .and. enforce_limits) then
            write(*,'(A)')' using Gaussian proposals with enforced limits'
         elseif (gaussian) then
            write(*,'(A)')' using Gaussian proposals'
         else
            write(*,'(A)')' using uniformly distributed proposals'
         endif
      endif
      write(*,'(6(a,i0))') '   Sampling columns with X(lon)=', &
            X_MCMC_MIN,':',X_MCMC_MAX,' of ',N_x,', Y(lat)=',Y_MCMC_MIN,':',Y_MCMC_MAX,' of ',N_y
      if (write_hdf5) then
         write(*,'(A,I0,A,I0,A)') '   Writing HDF5 after every ',write_numacc,' accepted proposals'
      endif
   elseif (synt) then
      write(*,*)'Simulation mode: creating a synthetic model; no MCMC steps'
   else
      write(*,*)'Simulation mode: solving a forward problem; no MCMC steps'
   endif
   call write_dashed_line()
   write(*,*)''

end subroutine print_grid_summary
